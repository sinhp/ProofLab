/- Copyright (c) 2022 Sina Hazratpour. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
----------------
# HW 13 
Sina Hazratpour
Introduction to Proof  
MATH 301, Johns Hopkins University, Fall 2022   
-/

import lectures.lec18_nat_trans
import tactic.basic

open PROOFS
open PROOFS.STR


open category_str

--infixr ` ‚ü∂ `:10 := precategory_str.hom -- type as \h
--notation `ùüô` := precategory_str.id -- type as \b1
-- infixr ` ‚äö `:80 := precategory_str.comp-- type as \oo
local notation f ` ‚äö `:80 g:80 := precategory_str.comp g f 

universes v‚ÇÅ v‚ÇÇ v‚ÇÉ v‚ÇÑ u‚ÇÅ u‚ÇÇ u‚ÇÉ u‚ÇÑ 
variables {ùìí : Type u‚ÇÅ} [category_str.{v‚ÇÅ} ùìí] {ùìì : Type u‚ÇÇ} [category_str.{v‚ÇÇ} ùìì]

/-! ## Q1. Construct the type of all groups. 
Show that this type admits the structure of a (large) category where 
morphisms are group homomorphisms.-/

structure mult_Group' := 
(carrier : Type)
(str : mult_group_str carrier )

#check mult_Group' -- type of all groups, carrier type equipped with a multiplicative group strucutre 

structure bundled (C : Type v‚ÇÅ ‚Üí Type u‚ÇÅ) :=
(carrier : Type*)
(str : C carrier )

instance (M : mult_Group') : mult_group_str M.carrier := M.str 


-- OUR GOAL IS FIRST TO DEFINE A CATEGORY WHERE MORPHISMS ARE GROUP HOMOMORPHISMS

@[ext] -- first we define a class of morphisms between group structures
--  A group morphism between groups `M` and `N` is given by a function `f : M ‚Üí N` which preserves the multiplication operation.
class mult_Group.morphism (M : Type u‚ÇÅ) (N : Type u‚ÇÅ) [mult_group_str M] [mult_group_str N] :=
(to_fun : M ‚Üí N) -- f : M ‚Üí N -- the underlying function of morphism
(resp_one : to_fun 1 = 1) -- f (1_M ) = 1_N
(resp_mul : ‚àÄ x y : M, to_fun (x * y) = to_fun x * to_fun y)

#check mult_Group.morphism

-- first we defined an identity morphism between group structures 
def mult_group.morphism.id {M : Type}[mult_group_str M] : mult_Group.morphism M M:= 
{
  to_fun := id, -- in order to define an identity function, we provide id 
  resp_one := by { -- our goal is to prove `id 1 = 1` 
    refl, -- By defintion `id 1` and `1` are equal 
    }, 
  resp_mul := by { -- our goal is to prove `‚àÄ (x y : M), id ( x * y) = id x * id y` 
  intros x y, -- First, we fix ` x y : M ` in the context 
  simp,}, -- since ` id x = x ` by defintion, ` id y = y ` by defintion, and ` id ( x * y ) = x * y `  by defintion, the goal can be written as ` x * y = x * y ` which is resolved since both sides are defintionally equal 
}

-- next we must define composition of group morphisms 
@[simp]
def mult_Group.morphism.comp {L M N : Type} [mult_group_str L] [mult_group_str M] [mult_group_str N] (g : mult_Group.morphism M N) (f : mult_Group.morphism L M) : mult_Group.morphism L N := 
{ to_fun := g.to_fun ‚àò f.to_fun, -- composotion of group morphisms is defined as the composition of the to_fun component of each group morphism
  resp_one := by { -- our goal is to prove `(morphism.to_fun ‚àò morphism.to_fun) 1 = 1` 
  dsimp, -- through simplification, the composition is simplified so that the goal turns into ` morphism.to_fun (morphism.to_fun 1) = 1`
  rw mult_Group.morphism.resp_one, -- our goal is to resolve `morphism.to_fun (morphism.to_fun 1) = 1` and there exists a mult_Group.morphism on g and f, a property of this morphism is that it respects one, therefore this property can be invoked 
  rw mult_Group.morphism.resp_one,}, -- our goal is to resolve ` morphism.to_fun 1 = 1 ` and since there exists a mult_Group.morphism on g and f, this resolves a property of this morphsim which resolves the goal 
  resp_mul := by { -- our goal is to prove `‚àÄ (x y : L), (morphism.to_fun ‚àò morphism.to_fun) (x * y) = (morphism.to_fun ‚àò morphism.to_fun) x * (morphism.to_fun ‚àò morphism.to_fun) y`
  intros x y, -- we fix ` x y : L ` in the context 
  dsimp, -- through simplification, the composition is simplified so that the goal turns into `morphism.to_fun (morphism.to_fun (x * y)) = morphism.to_fun (morphism.to_fun x) * morphism.to_fun (morphism.to_fun y`
  rw mult_Group.morphism.resp_mul, -- our goal is to resolve `morphism.to_fun (morphism.to_fun (x * y)) = morphism.to_fun (morphism.to_fun x) * morphism.to_fun (morphism.to_fun y` and since there exists a mult_Group.morphism on g and f, this resolves a property of this morphsim which resolves the goal 
  rw mult_Group.morphism.resp_mul, }, -- our goalis to resolve ` morphism.to_fun (morphism.to_fun x * morphism.to_fun y) = morphism.to_fun (morphism.to_fun x) * morphism.to_fun (morphism.to_fun y` and since there exists a mult_Group.morphism on g and f, this resolves a property of this morphsim which resolves the goal 
} 

-- in order to admit a category whose morphisms are group morphisms, we create lemmas which satifisy the fields of a category_str
@[simp]
lemma mult_group.morphism.id_comp {L M : Type} [mult_group_str L] [mult_group_str M]  (f : mult_Group.morphism L M)  : 
  mult_Group.morphism.comp f (mult_group.morphism.id) = f := 
begin 3
  ext, -- By extensionality, it is sufficient to prove the to_fun components of the morphism f and id when composed yields the original to_fun function
  refl, -- Our goal is transformed to `morphism.to_fun x = morphism.to_fun x` and both sides are definitionally equal 
end 

@[simp]
lemma mult_group.morphism.comp_id {L M : Type} [mult_group_str L] [mult_group_str M]  (f : mult_Group.morphism L M)  : 
  mult_Group.morphism.comp (mult_group.morphism.id) f = f := 
begin 
  ext, -- By extenstionality, it is sufficient to prove the to_fun components of the morphism f and id when composed yields the original to_fun function
  refl, -- Our goal is transformed to `morphism.to_fun x = morphism.to_fun x` and both sides are definitonally equal 
end 

@[simp]
def mult_group.morphism.comp_assoc {K L M N: Type} [mult_group_str K] [mult_group_str L] [mult_group_str M] [mult_group_str N] (f : mult_Group.morphism K L) (g : mult_Group.morphism L M) (h : mult_Group.morphism M N) : 
  mult_Group.morphism.comp (mult_Group.morphism.comp h g) f =  mult_Group.morphism.comp h (mult_Group.morphism.comp g f) := 
begin 
  refl, -- The goal is resolved since both sides of the equal sign are defintionally equal
end   


instance cat_of_groups : large_category_str (mult_Group') := 
{ hom := Œª X, Œª Y, mult_Group.morphism X.carrier Y.carrier, -- we first must provide a function which takes `mult_Group' ‚Üí mult_Group' ‚Üí Type` 
  id := Œª X, mult_group.morphism.id,  -- we first fix ` X : mult_Group' ` and next we provide a function ` X.carrier ‚Üí X.carrier `  
  comp := Œª X Y Z, Œª f g , mult_Group.morphism.comp g f, -- we first fix ` X Y Z : mult_Group'` in the context and ` f: mult_Group.morphism X.carrier Y.carrier` and ` g : mult_Group.morphism Y.carrier Z.carrier ` in the context as well, we then must define composition of multiplicative group structures which is given by `mult_Group.morphism.comp g f` 
  id_comp' := by { -- our goal is to prove `‚àÄ {X Y : mult_Group'} (f : X ‚ü∂ Y), f ‚äö ùüô X = f` 
    intros X Y, -- we fix `X Y : mult_Group` in the context
    exact mult_group.morphism.id_comp}, -- in order to prove composition with the id function yields the original function, we use the previously defined lemma 
  comp_id' := by { -- our goal is to prove `‚àÄ {X Y : mult_Group'} (f : X ‚ü∂ Y), ùüô Y ‚äö f = f` 
    intros X Y, -- we fix `X Y : mult_Group'` in the context
    exact mult_group.morphism.comp_id}, -- in order to prove composition with the id function yields the original function, we use the previously defined lemma 
  comp_assoc' := by { -- our goal is to prove `‚àÄ {W X Y Z : mult_Group'} (f : W ‚ü∂ X) (g : X ‚ü∂ Y) (h : Y ‚ü∂ Z), h ‚äö g ‚äö f = h ‚äö (g ‚äö f)` 
    intros W X Y Z, -- we fix ` W X Y Z : mult_Group' ` in the context
    exact mult_group.morphism.comp_assoc,} -- in order to prove composition is associative, we use the previously defined lemma 
    }

/-! ## Q2  Show that a monoid action gives rise to a functor from the 
delooping category of the monoid to the category of types. 
You can show that by filling in for the sorry placeholder in below. -/




def delooping_monoid_action (A : Type) [M : mult_Monoid] [mult_monoid_action M.carrier A] : 
(delooping_cat M).carrier ‚•§  Type* := 
{ obj := Œª X, A, -- for this field we must provide an instance `(delooping_cat M).carrier ‚Üí Type `
  mor := Œª X Y, _inst_3.smul, -- we fix ` X Y : (delooping_cat M).carrier ‚Üí Type` in the context, we then provide a function from `mult_monoid_action M.carrier A` 
  resp_id' := by { -- our goal is to solve ` ‚àÄ (X : (delooping_cat M).carrier), mult_monoid_action.smul (ùüô X) = ùüô A` 
  intro X, -- we fix ` X : (delooping_cat M).carrier ` in the context 
  simp [precategory_str.id], -- through simplification, ` ùüô A ` is reduced to `id` 
  have h‚ÇÉ: ‚àÄ (x : A), mult_monoid_action.smul ( 1 : M.carrier ) x = x, by {exact _inst_3.one_smul'}, -- we create a proof in the context which proves the propostion `‚àÄ (x : A), mult_monoid_action.smul 1 x = x` . The proof of this proposition derives from a property associated with mult_monoid_action
  funext,  -- since we are proving equality of functions, we evoke function extenstionality 
  simp, -- Through simplificatioin ` id x ` is reduced to ` x ` 
  have h‚ÇÖ : ùüô X = ( 1 : M.carrier), by {refl,}, -- we introduce a proof in the context which proves `ùüô X` and `( 1 : M.carrier)` are equal since this is known by defintion 
  rw h‚ÇÖ, -- there is `ùüô X` in the goal and we want to replace it by `1` to prove that `mult_monoid_action.smul 1 x = x` since we know `h‚ÇÖ` says something about the goal 
  exact h‚ÇÉ x,  -- the goal is resolved by invoking the proposition found in the context 
  },
  resp_comp' := by { -- our goal is to prove `‚àÄ {X Y Z : (delooping_cat M).carrier} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z), mult_monoid_action.smul (g ‚äö f) = mult_monoid_action.smul g ‚äö mult_monoid_action.smul f` 
  intros X Y Z f g, -- we fix ` X Y Z : (delooping_cat M).carrier ‚Üí Type` and ` f : X ‚ü∂ Y ` and `g : Y ‚ü∂ Z` in the context
  funext y, 
  rw ‚Üê _inst_3.mul_smul' f g y, 
  
  }
  }



/-! ## Question 4: The Arrow Category
Given a category ùìí we want to construct a new category whose objects are morphisms of ùìí and whose morphisms are commutative squares in ùìí.
 -/

@[ext]
structure arrow_type (ùìí : Type*) [small_category_str ùìí] :=
(dom : ùìí)
(cod : ùìí)
(arrow : dom ‚ü∂ cod)

#check arrow_type


local notation `ùî∏ùï£` : 10 := arrow_type


@[ext]
structure arrow_type_hom {ùìí : Type*}[small_category_str ùìí] (Œ± Œ≤ : ùî∏ùï£ ùìí ) :=
(top : Œ±.dom ‚ü∂ Œ≤.dom)
(bot : Œ±.cod ‚ü∂ Œ≤.cod)
(eq : Œ≤.arrow ‚äö top = bot ‚äö Œ±.arrow)


#check arrow_type_hom

/-
Show that we can equip `ùìí[‚Üí]` with the structure of a category where morphisms of ùìí and whose morphisms are commutative squares in ùìí.
-/


instance arrow_cat (ùìí : Type*)[small_category_str ùìí] : small_category_str (ùî∏ùï£ ùìí) :=
{ hom := Œª Œ±, Œª Œ≤, arrow_type_hom Œ± Œ≤ ,
  id := Œª Œ±, ‚ü®ùüô Œ±.dom, ùüô Œ±.cod, by {simp,}‚ü© , 
  comp := Œª X Y Z, Œª f, Œª g, ‚ü®  -- we must define composition of arrow_type_hom and in order to do this we fix ` X Y Z : ùî∏ùï£ ùìí ` and ` f : arrow_type_hom X Y` and ` g : arrow_type_hom Y Z` in the context and provide an instance of type arrow_type_hom which defines composition
    precategory_str.comp f.top g.top, -- for the first field, we compose the top function of the homomorphisms of f g 
  precategory_str.comp f.bot g.bot, -- for the second field, we compose the top function of the homomorphisms of f g 
  by { -- our goal is to prove `Z.arrow ‚äö (g.top ‚äö f.top) = g.bot ‚äö f.bot ‚äö X.arrow` 
  simp, -- through simplificaiton, the associativity of composition is utlized, in order to rewrite the goal as `Z.arrow ‚äö (g.top ‚äö f.top) = g.bot ‚äö (f.bot ‚äö X.arrow)` 
  have h‚ÇÇ: Y.arrow ‚äö f.top = f.bot ‚äö X.arrow , by {exact arrow_type_hom.eq f}, -- we create a proof in the context which proves the proposition ` Y.arrow ‚äö f.top = f.bot ‚äö X.arrow` which is proven by the `eq` property associated with the arrow_type_hom structure 
  have h‚ÇÉ: Z.arrow ‚äö g.top = g.bot ‚äö Y.arrow, by {exact arrow_type_hom.eq g}, -- we create a proof in the context which proves the proposition `Z.arrow ‚äö g.top = g.bot ‚äö Y.arrow` which is proven by the `eq` property associated ith the arrow_type_hom structure 
  rw ‚Üê h‚ÇÇ, -- there is `f.bot ‚äö X.arrow` in h‚ÇÇ and we want to replace it by `Y.arrow ‚äö f.top` to prove that `Z.arrow ‚äö (g.top ‚äö f.top) = g.bot ‚äö (Y.arrow ‚äö f.top)` since we know `h‚ÇÇ` says something about the goal 
  have h‚ÇÑ: (Z.arrow ‚äö g.top) ‚äö f.top = Z.arrow ‚äö (g.top ‚äö f.top), by {exact category_str.comp_assoc f.top g.top Z.arrow},  -- we create a proof in the context that proves the associativity of composition which is a property associated with category_str 
  rw ‚Üê h‚ÇÑ, -- there is `Z.arrow ‚äö (g.top ‚äö f.top)` in the goal and we want to replace it by `(Z.arrow ‚äö g.top) ‚äö f.top` to prove that `Z.arrow ‚äö g.top ‚äö f.top = g.bot (Y.arrow ‚äö f.top)` since we know `h‚ÇÑ` says something about the goal 
  rw h‚ÇÉ, -- there is `Z.arrow ‚äö g.top` in the goal and we want to replace it by `g.bot ‚äö Y.arrow` to prove that `g.bot ‚äö Y.arrow ‚äö f.top = g.bot ‚äö (Y.arrow ‚äö f.top)` since we know `h‚ÇÉ` says something about the goal 
  exact category_str.comp_assoc f.top Y.arrow g.bot,  -- a property associated with category_str is the associativity of composition which is required to resolve the goal 
   }
   ‚ü© ,
  id_comp' := by { -- our goal is to prove `‚àÄ {X Y : ùî∏ùï£ ùìí} (f : X ‚ü∂ Y), f ‚äö ùüô X = f` 
  intros X Y f,  -- we fix ` X Y : ùî∏ùï£ ùìí` and ` f : X ‚ü∂ Y ` in the context
  simp, -- Through simplification, properties concerning the composition of ùüô and the components of the arrow_type_hom is broken down
  ext, -- By extensionality, we can prove the homomorphisms are equal by proving the f.top functions are equal and the f.bottom functions are equal 
  {
    refl, -- Both sides of the propostion are definitionally equal, therefore the goal is resolved
  } ,
  {
    refl, -- Both sides of the propostion are definitionally equal, therefore the goal is resolved
  },
   },
  comp_id' := by { -- our goal is to prove `‚àÄ {X Y : ùî∏ùï£ ùìí} (f : X ‚ü∂ Y), ùüô Y ‚äö f = f`
  intros X Y f, -- we fix ` X Y : ùî∏ùï£ ùìí` and ` f : X ‚ü∂ Y ` in the context
  simp,  -- Through simplification, properties concerning the composition of ùüô and the components of the arrow_type_hom is broken down
  ext,  -- By extensionality, we can prove the homomorphisms are equal by proving the f.top functions are equal and the f.bottom functions are equal 
  {
    refl, -- Both sides of the propostion are definitionally equal, therefore the goal is resolved
  } ,
  {
    refl, -- Both sides of the propostion are definitionally equal, therefore the goal is resolved
  },
  },
  comp_assoc' := by { -- our goal is to prove ` ‚àÄ {W X Y Z : ùî∏ùï£ ùìí} (f : W ‚ü∂ X) (g : X ‚ü∂ Y) (h : Y ‚ü∂ Z), h ‚äö g ‚äö f = h ‚äö (g ‚äö f)` 
  intros Q X Y Z f g h, -- we fix ` Q X Y Z : ùî∏ùï£ ùìí ` and ` f : W ‚ü∂ X`  `g :X ‚ü∂ Y`  `h :  Y ‚ü∂ Z`  in the context
  ext,  -- By extensionality, we can prove the homomorphisms are equal by proving the f.top functions are equal and the f.bottom functions are equal 
  {
    exact category_str.comp_assoc f.top g.top h.top, -- we invoke the property that composition is associative associated with category_str
  },
  {
    exact category_str.comp_assoc f.bot g.bot h.bot, -- we invoke the property that composition is associative associated with category_str
  },
  }, 
  }



/-
We shall define two functors form `ùî∏ùï£ ùìí` to `ùìí`: `Dom` and `Cod`. `Dom` takes an arrow `f : X ‚ü∂ Y` to its domain `X` and `Cod` takes `f` to `Y`.
-/


def Dom (ùìí : Type*)[small_category_str ùìí] :
  (ùî∏ùï£ ùìí) ‚•§ ùìí :=
{ obj := Œª Œ±, Œ±.dom, 
  mor := Œª X Y, Œª f, arrow_type_hom.top f, -- we fix ` X Y : ùî∏ùï£ ùìí` in the context `f : X ‚ü∂ Y` and provide a function from `X.dom ‚ü∂ Y.dom` which is satisfied through the top function associated with arrow_type_hom structure
  resp_id' := by {-- our goal is to prove ` ‚àÄ (X : ùî∏ùï£ ùìí), (ùüô X).top = ùüô X.dom`
    intro X, -- we fix ` X : ùî∏ùï£ ùìí ` in the context
  simp only [precategory_str.id]}, -- we resolve the goal through simplification of the id function associatiated with the precategory_str
  resp_comp' := by { -- our goal is to prove `‚àÄ {X Y Z : ùî∏ùï£ ùìí} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z), (g ‚äö f).top = g.top ‚äö f.top`
    intros A B C f g, -- we fix ` A B C : ùî∏ùï£ ùìí ` in the context ` f: A  ‚ü∂ B ` and ` g : B ‚ü∂ C ` in the context
    simp only [precategory_str.comp],}, } -- we resolve the goal through simplification of the defntion of composition associated with the pre_category_str


def Cod (ùìí : Type*)[small_category_str ùìí] :
  (ùî∏ùï£ ùìí) ‚•§ ùìí :=
{ obj := Œª Œ±, Œ±.cod,
  mor := Œª X Y, Œª f, arrow_type_hom.bot f, -- we fix ` X Y : ùî∏ùï£ ùìí` in the context `f : X ‚ü∂ Y` and provide a function from `X.cod ‚Üí Y.cod` which is satisfied through the top function associated with arrow_type_hom structure
  resp_id' := by { -- our goal is to prove `‚àÄ (X : ùî∏ùï£ ùìí), (ùüô X).bot = ùüô X.cod` 
  intro X, -- we fix ` X :  ùî∏ùï£ ùìí ` in the context 
  simp only [precategory_str.id]}, -- we resolve the goal through simplification of the id function associatiated with the precategory_str
  resp_comp' := by { -- our goal is to prove `‚àÄ {X Y Z : ùî∏ùï£ ùìí} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z), (g ‚äö f).bot = g.bot ‚äö f.bot`
  intros A B C f g,  -- we fix ` A B C : ùî∏ùï£ ùìí ` in the context ` f: A  ‚ü∂ B ` and ` g : B ‚ü∂ C ` in the context
  simp only [precategory_str.comp], --  -- we resolve the goal through simplification of the defntion of composition associated with the pre_category_str
  }, }



/- Theorem:
For functors `F G : ùìí ‚•§ ùìì`, the type of natural transformations `F ‚ü∂ G` is equivalent to the type of functors `ùìí ‚•§ ùî∏ùï£ ùìì`  whose composition with `Dom` and `Cod` are equal to `F` and `G` respectively.

Therefore, the arrow category classifies natural transformations.
-/

local notation F ` ‚äö‚äö `:80 G:80 := category_str.functor.comp G F



def arrow_cat_classifies_nat_trans {ùìí ùìì : Type*}[small_category_str ùìí] [small_category_str ùìì] (F G : ùìí ‚•§ ùìì) :
(F ‚ü∂ G) ‚âÖ { H : ùìí ‚•§ ùî∏ùï£ ùìì // ( (Dom ùìì) ‚äö‚äö H = F ) ‚àß ((Cod ùìì) ‚äö‚äö H = G) }  :=
{ to_mor := Œª f,
‚ü® {
  obj := Œª a, ‚ü®F.obj a, G.obj a, nat_trans.cmpt F.obj G.obj‚ü© ,
  mor := Œª X Y f, sorry,
  resp_id' := sorry, 
  resp_comp' := sorry, 
}, 
by {split, 
{

},
{

},
} 
‚ü©,
  inv_mor := Œª f,
‚ü® {
  obj := Œª a,,
  mor := Œª X Y f, sorry,
  resp_id' := sorry, 
  resp_comp' := sorry, 
}, 
by {split, 
{

},
{

},
} 
‚ü©,
,
  left_inv := _,
  right_inv := _ }


/-! ## Question 3: Yoneda Problem -/


open nat_trans

def Yoneda (X Y : ùìí) (Œ± : ‚Ñçom.obj X ‚âÖ  ‚Ñçom.obj Y) : 
  X ‚âÖ Y :=
{ 
  to_mor := Œ±.to_mor.cmpt (op X) (ùüô X),
  inv_mor := Œ±.inv_mor.cmpt (op Y) (ùüô Y),
  left_inv := by { have h‚ÇÅ, from Œ±.inv_mor.naturality (Œ±.to_mor.cmpt (op X) (ùüô X)), 
  simp at h‚ÇÅ, 

  sorry, },
  right_inv := sorry, 
}



















